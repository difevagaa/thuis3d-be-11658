import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { decode as decodePng } from "https://deno.land/x/pngs@0.1.1/mod.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Bambu Labs LED light dimensions (in mm)
const BAMBU_LIGHT_DIAMETER = 16;
const BAMBU_LIGHT_HEIGHT = 8;
const LIGHT_HOLE_CLEARANCE = 0.5;

// Lithophane parameters for printability
const MIN_THICKNESS = 0.8; // mm - for bright areas (more light passes)
const MAX_THICKNESS = 3.0; // mm - for dark areas (less light passes)
const EDGE_REINFORCEMENT = 1.5; // mm extra on edges

// STL Binary Header
function createSTLHeader(triangleCount: number): Uint8Array {
  const header = new Uint8Array(84);
  const headerText = "Lithophane STL - Generated by Lovable";
  for (let i = 0; i < Math.min(headerText.length, 80); i++) {
    header[i] = headerText.charCodeAt(i);
  }
  const view = new DataView(header.buffer);
  view.setUint32(80, triangleCount, true);
  return header;
}

// Add triangle to buffer
function addTriangle(
  buffer: Float32Array,
  offset: number,
  normal: [number, number, number],
  v1: [number, number, number],
  v2: [number, number, number],
  v3: [number, number, number]
): number {
  buffer[offset++] = normal[0];
  buffer[offset++] = normal[1];
  buffer[offset++] = normal[2];
  buffer[offset++] = v1[0];
  buffer[offset++] = v1[1];
  buffer[offset++] = v1[2];
  buffer[offset++] = v2[0];
  buffer[offset++] = v2[1];
  buffer[offset++] = v2[2];
  buffer[offset++] = v3[0];
  buffer[offset++] = v3[1];
  buffer[offset++] = v3[2];
  return offset;
}

// Calculate normal for triangle
function calculateNormal(
  v1: [number, number, number],
  v2: [number, number, number],
  v3: [number, number, number]
): [number, number, number] {
  const u: [number, number, number] = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
  const v: [number, number, number] = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
  
  const n: [number, number, number] = [
    u[1] * v[2] - u[2] * v[1],
    u[2] * v[0] - u[0] * v[2],
    u[0] * v[1] - u[1] * v[0]
  ];
  
  const len = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
  if (len > 0) {
    n[0] /= len;
    n[1] /= len;
    n[2] /= len;
  }
  
  return n;
}

// Decode image and extract grayscale data
async function decodeImageToGrayscale(
  imageBuffer: ArrayBuffer,
  contentType: string
): Promise<{ data: Uint8Array; width: number; height: number }> {
  console.log(`Decoding image, content type: ${contentType}, size: ${imageBuffer.byteLength} bytes`);
  
  const uint8Array = new Uint8Array(imageBuffer);
  
  // Check for PNG signature
  const isPng = uint8Array[0] === 0x89 && uint8Array[1] === 0x50 && 
                uint8Array[2] === 0x4E && uint8Array[3] === 0x47;
  
  if (isPng) {
    try {
      const decoded = decodePng(uint8Array);
      console.log(`PNG decoded: ${decoded.width}x${decoded.height}`);
      
      // Convert to grayscale
      const grayscale = new Uint8Array(decoded.width * decoded.height);
      const pixelData = decoded.image;
      
      for (let i = 0; i < decoded.width * decoded.height; i++) {
        const idx = i * 4;
        // Luminosity formula for better grayscale conversion
        const gray = Math.round(
          0.299 * pixelData[idx] + 
          0.587 * pixelData[idx + 1] + 
          0.114 * pixelData[idx + 2]
        );
        grayscale[i] = gray;
      }
      
      return { data: grayscale, width: decoded.width, height: decoded.height };
    } catch (pngError) {
      console.error('PNG decode error:', pngError);
    }
  }
  
  // For JPEG or failed PNG, create grayscale from raw estimation
  // This is a fallback - in production you'd use a proper JPEG decoder
  console.log('Using fallback grayscale generation');
  
  // Estimate dimensions from file size (rough approximation)
  const estimatedPixels = Math.floor(imageBuffer.byteLength / 3);
  const estimatedDim = Math.floor(Math.sqrt(estimatedPixels));
  const width = Math.min(Math.max(estimatedDim, 100), 500);
  const height = width;
  
  // Create grayscale from byte patterns in the image
  const grayscale = new Uint8Array(width * height);
  const step = Math.floor(uint8Array.length / (width * height));
  
  for (let i = 0; i < width * height; i++) {
    const byteIdx = Math.min(i * step, uint8Array.length - 1);
    // Use byte values directly as grayscale approximation
    grayscale[i] = uint8Array[byteIdx];
  }
  
  return { data: grayscale, width, height };
}

// Resample grayscale image to target resolution
function resampleGrayscale(
  data: Uint8Array,
  srcWidth: number,
  srcHeight: number,
  targetWidth: number,
  targetHeight: number
): Uint8Array {
  const result = new Uint8Array(targetWidth * targetHeight);
  const scaleX = srcWidth / targetWidth;
  const scaleY = srcHeight / targetHeight;
  
  for (let y = 0; y < targetHeight; y++) {
    for (let x = 0; x < targetWidth; x++) {
      const srcX = Math.floor(x * scaleX);
      const srcY = Math.floor(y * scaleY);
      const srcIdx = srcY * srcWidth + srcX;
      result[y * targetWidth + x] = data[srcIdx];
    }
  }
  
  return result;
}

// Generate lithophane mesh from grayscale data
function generateLithophanyMesh(
  grayscaleData: Uint8Array,
  width: number,
  height: number,
  physicalWidth: number,
  physicalHeight: number,
  shapeType: string = 'flat'
): { triangles: Float32Array; count: number } {
  console.log(`Generating lithophany mesh: ${width}x${height}px -> ${physicalWidth}x${physicalHeight}mm, shape: ${shapeType}`);
  
  const scaleX = physicalWidth / width;
  const scaleY = physicalHeight / height;
  
  // Calculate heights from grayscale values (inverted: dark = thick)
  const heights: number[][] = [];
  for (let y = 0; y < height; y++) {
    heights[y] = [];
    for (let x = 0; x < width; x++) {
      const gray = grayscaleData[y * width + x];
      // Invert: darker pixels (low gray value) = thicker = less light passes
      const normalizedHeight = 1 - (gray / 255);
      heights[y][x] = MIN_THICKNESS + normalizedHeight * (MAX_THICKNESS - MIN_THICKNESS);
    }
  }
  
  // Add edge reinforcement
  for (let y = 0; y < height; y++) {
    heights[y][0] = Math.max(heights[y][0], EDGE_REINFORCEMENT);
    heights[y][width - 1] = Math.max(heights[y][width - 1], EDGE_REINFORCEMENT);
  }
  for (let x = 0; x < width; x++) {
    heights[0][x] = Math.max(heights[0][x], EDGE_REINFORCEMENT);
    heights[height - 1][x] = Math.max(heights[height - 1][x], EDGE_REINFORCEMENT);
  }
  
  // Generate triangles
  const cellsX = width - 1;
  const cellsY = height - 1;
  
  // Estimate triangle count
  const estimatedTriangles = cellsX * cellsY * 2 * 2 + (cellsX + cellsY) * 2 * 2;
  const triangles = new Float32Array(estimatedTriangles * 12 * 2);
  let offset = 0;
  let triangleCount = 0;
  
  // Apply shape transformation based on type
  const transformPoint = (x: number, y: number, z: number): [number, number, number] => {
    if (shapeType === 'cylinder_small' || shapeType === 'cylinder_medium' || shapeType === 'cylinder_large') {
      // Wrap around Y axis
      const angle = (x / physicalWidth) * Math.PI * 2;
      const radius = physicalWidth / (Math.PI * 2);
      return [
        Math.cos(angle) * (radius + z),
        y,
        Math.sin(angle) * (radius + z)
      ];
    } else if (shapeType === 'half_cylinder') {
      // Half wrap around Y axis
      const angle = (x / physicalWidth) * Math.PI;
      const radius = physicalWidth / Math.PI;
      return [
        Math.cos(angle) * (radius + z),
        y,
        Math.sin(angle) * (radius + z)
      ];
    } else if (shapeType === 'curved_soft' || shapeType === 'curved_deep') {
      // Curved along X axis
      const curveAmount = shapeType === 'curved_deep' ? 0.3 : 0.15;
      const curveZ = Math.sin((x / physicalWidth) * Math.PI) * physicalWidth * curveAmount;
      return [x, y, z + curveZ];
    } else if (shapeType === 'moon') {
      // Spherical segment
      const centerX = physicalWidth / 2;
      const centerY = physicalHeight / 2;
      const radius = Math.min(physicalWidth, physicalHeight) / 2;
      const dx = x - centerX;
      const dy = y - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < radius) {
        const sphereZ = Math.sqrt(radius * radius - dist * dist) * 0.3;
        return [x, y, z + sphereZ];
      }
      return [x, y, z];
    }
    // Default flat
    return [x, y, z];
  };
  
  // Generate top surface
  for (let y = 0; y < cellsY; y++) {
    for (let x = 0; x < cellsX; x++) {
      const x1 = x * scaleX;
      const x2 = (x + 1) * scaleX;
      const y1 = y * scaleY;
      const y2 = (y + 1) * scaleY;
      
      const z00 = heights[y][x];
      const z10 = heights[y][x + 1];
      const z01 = heights[y + 1][x];
      const z11 = heights[y + 1][x + 1];
      
      const v1 = transformPoint(x1, y1, z00);
      const v2 = transformPoint(x2, y1, z10);
      const v3 = transformPoint(x1, y2, z01);
      const n1 = calculateNormal(v1, v2, v3);
      offset = addTriangle(triangles, offset, n1, v1, v2, v3);
      triangleCount++;
      
      const v4 = transformPoint(x2, y1, z10);
      const v5 = transformPoint(x2, y2, z11);
      const v6 = transformPoint(x1, y2, z01);
      const n2 = calculateNormal(v4, v5, v6);
      offset = addTriangle(triangles, offset, n2, v4, v5, v6);
      triangleCount++;
    }
  }
  
  // Generate bottom surface (flat at z=0)
  for (let y = 0; y < cellsY; y++) {
    for (let x = 0; x < cellsX; x++) {
      const x1 = x * scaleX;
      const x2 = (x + 1) * scaleX;
      const y1 = y * scaleY;
      const y2 = (y + 1) * scaleY;
      
      const v1 = transformPoint(x1, y1, 0);
      const v2 = transformPoint(x1, y2, 0);
      const v3 = transformPoint(x2, y1, 0);
      offset = addTriangle(triangles, offset, [0, 0, -1], v1, v2, v3);
      triangleCount++;
      
      const v4 = transformPoint(x2, y1, 0);
      const v5 = transformPoint(x1, y2, 0);
      const v6 = transformPoint(x2, y2, 0);
      offset = addTriangle(triangles, offset, [0, 0, -1], v4, v5, v6);
      triangleCount++;
    }
  }
  
  // Generate side walls
  // Left side (x = 0)
  for (let y = 0; y < cellsY; y++) {
    const y1 = y * scaleY;
    const y2 = (y + 1) * scaleY;
    const z1 = heights[y][0];
    const z2 = heights[y + 1][0];
    
    offset = addTriangle(triangles, offset, [-1, 0, 0],
      transformPoint(0, y1, 0), transformPoint(0, y2, 0), transformPoint(0, y1, z1));
    triangleCount++;
    offset = addTriangle(triangles, offset, [-1, 0, 0],
      transformPoint(0, y2, 0), transformPoint(0, y2, z2), transformPoint(0, y1, z1));
    triangleCount++;
  }
  
  // Right side (x = max)
  for (let y = 0; y < cellsY; y++) {
    const y1 = y * scaleY;
    const y2 = (y + 1) * scaleY;
    const z1 = heights[y][width - 1];
    const z2 = heights[y + 1][width - 1];
    
    offset = addTriangle(triangles, offset, [1, 0, 0],
      transformPoint(physicalWidth, y1, 0), transformPoint(physicalWidth, y1, z1), transformPoint(physicalWidth, y2, 0));
    triangleCount++;
    offset = addTriangle(triangles, offset, [1, 0, 0],
      transformPoint(physicalWidth, y2, 0), transformPoint(physicalWidth, y1, z1), transformPoint(physicalWidth, y2, z2));
    triangleCount++;
  }
  
  // Front side (y = 0)
  for (let x = 0; x < cellsX; x++) {
    const x1 = x * scaleX;
    const x2 = (x + 1) * scaleX;
    const z1 = heights[0][x];
    const z2 = heights[0][x + 1];
    
    offset = addTriangle(triangles, offset, [0, -1, 0],
      transformPoint(x1, 0, 0), transformPoint(x1, 0, z1), transformPoint(x2, 0, 0));
    triangleCount++;
    offset = addTriangle(triangles, offset, [0, -1, 0],
      transformPoint(x2, 0, 0), transformPoint(x1, 0, z1), transformPoint(x2, 0, z2));
    triangleCount++;
  }
  
  // Back side (y = max)
  for (let x = 0; x < cellsX; x++) {
    const x1 = x * scaleX;
    const x2 = (x + 1) * scaleX;
    const z1 = heights[height - 1][x];
    const z2 = heights[height - 1][x + 1];
    
    offset = addTriangle(triangles, offset, [0, 1, 0],
      transformPoint(x1, physicalHeight, 0), transformPoint(x2, physicalHeight, 0), transformPoint(x1, physicalHeight, z1));
    triangleCount++;
    offset = addTriangle(triangles, offset, [0, 1, 0],
      transformPoint(x2, physicalHeight, 0), transformPoint(x2, physicalHeight, z2), transformPoint(x1, physicalHeight, z1));
    triangleCount++;
  }
  
  console.log(`Generated ${triangleCount} triangles for lithophany`);
  return { triangles: triangles.slice(0, offset), count: triangleCount };
}

// Generate base with LED hole and screen slot
function generateBaseMesh(
  baseWidth: number,
  baseDepth: number,
  baseHeight: number,
  ledDiameter: number,
  ledDepth: number,
  screenSlotWidth: number,
  screenSlotDepth: number = 3,
  segments: number = 32
): { triangles: Float32Array; count: number } {
  console.log(`Generating base mesh: ${baseWidth}x${baseDepth}x${baseHeight}mm, LED: ${ledDiameter}mm, slot: ${screenSlotWidth}mm`);
  
  const triangles: number[] = [];
  const ledRadius = ledDiameter / 2;
  const centerX = baseWidth / 2;
  const centerY = baseDepth / 2;
  
  const addTri = (n: [number, number, number], v1: [number, number, number], v2: [number, number, number], v3: [number, number, number]) => {
    triangles.push(n[0], n[1], n[2], v1[0], v1[1], v1[2], v2[0], v2[1], v2[2], v3[0], v3[1], v3[2]);
  };
  
  // Bottom face
  addTri([0, 0, -1], [0, 0, 0], [baseWidth, 0, 0], [0, baseDepth, 0]);
  addTri([0, 0, -1], [baseWidth, 0, 0], [baseWidth, baseDepth, 0], [0, baseDepth, 0]);
  
  // Top face with LED hole (grid approach)
  const gridSize = 2;
  const gridX = Math.ceil(baseWidth / gridSize);
  const gridY = Math.ceil(baseDepth / gridSize);
  
  for (let gy = 0; gy < gridY; gy++) {
    for (let gx = 0; gx < gridX; gx++) {
      const x1 = gx * gridSize;
      const x2 = Math.min((gx + 1) * gridSize, baseWidth);
      const y1 = gy * gridSize;
      const y2 = Math.min((gy + 1) * gridSize, baseDepth);
      
      const cellCenterX = (x1 + x2) / 2;
      const cellCenterY = (y1 + y2) / 2;
      const distFromCenter = Math.sqrt(
        Math.pow(cellCenterX - centerX, 2) + 
        Math.pow(cellCenterY - centerY, 2)
      );
      
      if (distFromCenter > ledRadius + gridSize) {
        addTri([0, 0, 1], [x1, y1, baseHeight], [x2, y2, baseHeight], [x2, y1, baseHeight]);
        addTri([0, 0, 1], [x1, y1, baseHeight], [x1, y2, baseHeight], [x2, y2, baseHeight]);
      }
    }
  }
  
  // LED hole walls
  const holeBottom = baseHeight - ledDepth;
  for (let i = 0; i < segments; i++) {
    const angle1 = (i / segments) * Math.PI * 2;
    const angle2 = ((i + 1) / segments) * Math.PI * 2;
    
    const x1 = centerX + Math.cos(angle1) * ledRadius;
    const y1 = centerY + Math.sin(angle1) * ledRadius;
    const x2 = centerX + Math.cos(angle2) * ledRadius;
    const y2 = centerY + Math.sin(angle2) * ledRadius;
    
    const nx1 = -Math.cos(angle1);
    const ny1 = -Math.sin(angle1);
    const nx2 = -Math.cos(angle2);
    const ny2 = -Math.sin(angle2);
    const avgN: [number, number, number] = [-(nx1 + nx2) / 2, -(ny1 + ny2) / 2, 0];
    
    addTri(avgN, [x1, y1, baseHeight], [x2, y2, baseHeight], [x1, y1, holeBottom]);
    addTri(avgN, [x2, y2, baseHeight], [x2, y2, holeBottom], [x1, y1, holeBottom]);
    
    addTri([0, 0, -1], [centerX, centerY, holeBottom], [x2, y2, holeBottom], [x1, y1, holeBottom]);
  }
  
  // Screen slot on top (back edge)
  const slotX1 = (baseWidth - screenSlotWidth) / 2;
  const slotX2 = slotX1 + screenSlotWidth;
  const slotY1 = baseDepth - screenSlotDepth - 2;
  const slotY2 = baseDepth - 2;
  const slotZ = baseHeight - 2;
  
  // Slot bottom
  addTri([0, 0, 1], [slotX1, slotY1, slotZ], [slotX2, slotY1, slotZ], [slotX1, slotY2, slotZ]);
  addTri([0, 0, 1], [slotX2, slotY1, slotZ], [slotX2, slotY2, slotZ], [slotX1, slotY2, slotZ]);
  
  // Slot walls
  addTri([0, -1, 0], [slotX1, slotY1, slotZ], [slotX1, slotY1, baseHeight], [slotX2, slotY1, slotZ]);
  addTri([0, -1, 0], [slotX2, slotY1, slotZ], [slotX1, slotY1, baseHeight], [slotX2, slotY1, baseHeight]);
  
  addTri([0, 1, 0], [slotX1, slotY2, slotZ], [slotX2, slotY2, slotZ], [slotX1, slotY2, baseHeight]);
  addTri([0, 1, 0], [slotX2, slotY2, slotZ], [slotX2, slotY2, baseHeight], [slotX1, slotY2, baseHeight]);
  
  addTri([-1, 0, 0], [slotX1, slotY1, slotZ], [slotX1, slotY2, slotZ], [slotX1, slotY1, baseHeight]);
  addTri([-1, 0, 0], [slotX1, slotY2, slotZ], [slotX1, slotY2, baseHeight], [slotX1, slotY1, baseHeight]);
  
  addTri([1, 0, 0], [slotX2, slotY1, slotZ], [slotX2, slotY1, baseHeight], [slotX2, slotY2, slotZ]);
  addTri([1, 0, 0], [slotX2, slotY2, slotZ], [slotX2, slotY1, baseHeight], [slotX2, slotY2, baseHeight]);
  
  // Side walls
  addTri([0, -1, 0], [0, 0, 0], [0, 0, baseHeight], [baseWidth, 0, 0]);
  addTri([0, -1, 0], [baseWidth, 0, 0], [0, 0, baseHeight], [baseWidth, 0, baseHeight]);
  
  addTri([0, 1, 0], [0, baseDepth, 0], [baseWidth, baseDepth, 0], [0, baseDepth, baseHeight]);
  addTri([0, 1, 0], [baseWidth, baseDepth, 0], [baseWidth, baseDepth, baseHeight], [0, baseDepth, baseHeight]);
  
  addTri([-1, 0, 0], [0, 0, 0], [0, baseDepth, 0], [0, 0, baseHeight]);
  addTri([-1, 0, 0], [0, baseDepth, 0], [0, baseDepth, baseHeight], [0, 0, baseHeight]);
  
  addTri([1, 0, 0], [baseWidth, 0, 0], [baseWidth, 0, baseHeight], [baseWidth, baseDepth, 0]);
  addTri([1, 0, 0], [baseWidth, baseDepth, 0], [baseWidth, 0, baseHeight], [baseWidth, baseDepth, baseHeight]);
  
  const triangleCount = triangles.length / 12;
  console.log(`Generated ${triangleCount} triangles for base with slot`);
  
  return { 
    triangles: new Float32Array(triangles), 
    count: triangleCount 
  };
}

// Create binary STL file
function createBinarySTL(triangles: Float32Array, triangleCount: number): Uint8Array {
  const header = createSTLHeader(triangleCount);
  const triangleData = new Uint8Array(triangleCount * 50);
  
  const dataView = new DataView(triangleData.buffer);
  let byteOffset = 0;
  let floatOffset = 0;
  
  for (let i = 0; i < triangleCount; i++) {
    for (let j = 0; j < 12; j++) {
      dataView.setFloat32(byteOffset, triangles[floatOffset++], true);
      byteOffset += 4;
    }
    dataView.setUint16(byteOffset, 0, true);
    byteOffset += 2;
  }
  
  const result = new Uint8Array(header.length + triangleData.length);
  result.set(header, 0);
  result.set(triangleData, header.length);
  
  return result;
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { orderId, generateBase = true } = await req.json();
    
    if (!orderId) {
      return new Response(
        JSON.stringify({ error: 'Order ID is required' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log(`Processing STL generation for order: ${orderId}`);

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    const { data: order, error: orderError } = await supabase
      .from('lithophany_orders')
      .select('*')
      .eq('id', orderId)
      .single();

    if (orderError || !order) {
      console.error('Order not found:', orderError);
      return new Response(
        JSON.stringify({ error: 'Order not found' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log('Order found:', order.id, 'Dimensions:', order.lamp_width_mm, 'x', order.lamp_height_mm);

    // Validate minimum dimensions
    const minDimension = 10; // mm
    if (order.lamp_width_mm < minDimension || order.lamp_height_mm < minDimension) {
      return new Response(
        JSON.stringify({ 
          error: `Dimensions must be at least ${minDimension}mm. Got: ${order.lamp_width_mm}x${order.lamp_height_mm}mm` 
        }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Fetch and process the image
    const imageUrl = order.processed_image_url || order.original_image_url;
    console.log('Fetching image:', imageUrl);
    
    const imageResponse = await fetch(imageUrl);
    if (!imageResponse.ok) {
      throw new Error(`Failed to fetch image: ${imageResponse.status}`);
    }
    
    const contentType = imageResponse.headers.get('content-type') || 'image/png';
    const imageBuffer = await imageResponse.arrayBuffer();
    
    // Decode image to grayscale
    const decoded = await decodeImageToGrayscale(imageBuffer, contentType);
    console.log(`Image decoded: ${decoded.width}x${decoded.height}`);
    
    // Calculate target resolution (limit for performance)
    const maxResolution = 200; // pixels per dimension
    const aspectRatio = decoded.width / decoded.height;
    let targetWidth: number, targetHeight: number;
    
    if (aspectRatio > 1) {
      targetWidth = Math.min(decoded.width, maxResolution);
      targetHeight = Math.round(targetWidth / aspectRatio);
    } else {
      targetHeight = Math.min(decoded.height, maxResolution);
      targetWidth = Math.round(targetHeight * aspectRatio);
    }
    
    // Resample to target resolution
    const resampledData = resampleGrayscale(
      decoded.data,
      decoded.width,
      decoded.height,
      targetWidth,
      targetHeight
    );
    
    // Get shape type from order
    const shapeType = order.lamp_type || 'flat';
    
    // Generate lithophane mesh
    const lithophanyMesh = generateLithophanyMesh(
      resampledData,
      targetWidth,
      targetHeight,
      order.lamp_width_mm,
      order.lamp_height_mm,
      shapeType
    );
    
    const lithophanySTL = createBinarySTL(lithophanyMesh.triangles, lithophanyMesh.count);
    console.log('Lithophane STL size:', lithophanySTL.length, 'bytes');
    
    const timestamp = Date.now();
    const lithophanyFileName = `lithophany/${order.user_id}/${orderId}_lithophane_${timestamp}.stl`;
    
    const { error: uploadError } = await supabase.storage
      .from('uploads')
      .upload(lithophanyFileName, lithophanySTL, {
        contentType: 'application/sla',
        upsert: true
      });
    
    if (uploadError) {
      console.error('Failed to upload lithophane STL:', uploadError);
      throw new Error('Failed to upload lithophane STL');
    }
    
    const { data: lithophanyUrl } = supabase.storage
      .from('uploads')
      .getPublicUrl(lithophanyFileName);
    
    let baseUrl = null;
    
    if (generateBase) {
      const baseWidth = order.base_width_mm || order.lamp_width_mm * 1.2;
      const baseDepth = order.base_depth_mm || 25;
      const baseHeight = order.base_height_mm || 15;
      const ledDiameter = order.light_hole_diameter_mm || BAMBU_LIGHT_DIAMETER + LIGHT_HOLE_CLEARANCE;
      const ledDepth = order.light_hole_depth_mm || BAMBU_LIGHT_HEIGHT + 2;
      
      const baseMesh = generateBaseMesh(
        baseWidth,
        baseDepth,
        baseHeight,
        ledDiameter,
        ledDepth,
        order.lamp_width_mm // Screen slot width matches lamp width
      );
      
      const baseSTL = createBinarySTL(baseMesh.triangles, baseMesh.count);
      console.log('Base STL size:', baseSTL.length, 'bytes');
      
      const baseFileName = `lithophany/${order.user_id}/${orderId}_base_${timestamp}.stl`;
      
      const { error: baseUploadError } = await supabase.storage
        .from('uploads')
        .upload(baseFileName, baseSTL, {
          contentType: 'application/sla',
          upsert: true
        });
      
      if (baseUploadError) {
        console.error('Failed to upload base STL:', baseUploadError);
      } else {
        const { data: baseUrlData } = supabase.storage
          .from('uploads')
          .getPublicUrl(baseFileName);
        baseUrl = baseUrlData.publicUrl;
      }
    }
    
    // Update order with STL URLs
    const { error: updateError } = await supabase
      .from('lithophany_orders')
      .update({
        lithophany_stl_url: lithophanyUrl.publicUrl,
        base_stl_url: baseUrl,
        processed_at: new Date().toISOString(),
        status: 'processed'
      })
      .eq('id', orderId);
    
    if (updateError) {
      console.error('Failed to update order:', updateError);
    }
    
    console.log('STL generation complete for order:', orderId);
    
    return new Response(
      JSON.stringify({
        success: true,
        lithophanyStlUrl: lithophanyUrl.publicUrl,
        baseStlUrl: baseUrl,
        message: 'STL files generated successfully'
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
    
  } catch (error) {
    console.error('Error generating STL:', error);
    const errorMessage = error instanceof Error ? error.message : 'Failed to generate STL';
    return new Response(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
