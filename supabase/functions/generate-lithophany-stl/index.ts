import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Bambu Labs LED light dimensions (in mm)
const BAMBU_LIGHT_DIAMETER = 16;
const BAMBU_LIGHT_HEIGHT = 8;
const LIGHT_HOLE_CLEARANCE = 0.5; // Extra clearance for fit

// STL Binary Header
function createSTLHeader(triangleCount: number): Uint8Array {
  const header = new Uint8Array(84);
  // 80 bytes header (can be anything)
  const headerText = "Lithophane STL - Generated by Lovable";
  for (let i = 0; i < Math.min(headerText.length, 80); i++) {
    header[i] = headerText.charCodeAt(i);
  }
  // 4 bytes triangle count (little-endian)
  const view = new DataView(header.buffer);
  view.setUint32(80, triangleCount, true);
  return header;
}

// Add triangle to buffer
function addTriangle(
  buffer: Float32Array,
  offset: number,
  normal: [number, number, number],
  v1: [number, number, number],
  v2: [number, number, number],
  v3: [number, number, number]
): number {
  // Normal
  buffer[offset++] = normal[0];
  buffer[offset++] = normal[1];
  buffer[offset++] = normal[2];
  // Vertex 1
  buffer[offset++] = v1[0];
  buffer[offset++] = v1[1];
  buffer[offset++] = v1[2];
  // Vertex 2
  buffer[offset++] = v2[0];
  buffer[offset++] = v2[1];
  buffer[offset++] = v2[2];
  // Vertex 3
  buffer[offset++] = v3[0];
  buffer[offset++] = v3[1];
  buffer[offset++] = v3[2];
  return offset;
}

// Calculate normal for triangle
function calculateNormal(
  v1: [number, number, number],
  v2: [number, number, number],
  v3: [number, number, number]
): [number, number, number] {
  const u: [number, number, number] = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
  const v: [number, number, number] = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
  
  const n: [number, number, number] = [
    u[1] * v[2] - u[2] * v[1],
    u[2] * v[0] - u[0] * v[2],
    u[0] * v[1] - u[1] * v[0]
  ];
  
  const len = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
  if (len > 0) {
    n[0] /= len;
    n[1] /= len;
    n[2] /= len;
  }
  
  return n;
}

// Generate lithophane mesh from grayscale image data
function generateLithophanyMesh(
  imageData: Uint8ClampedArray,
  width: number,
  height: number,
  physicalWidth: number,
  physicalHeight: number,
  minThickness: number = 0.8,
  maxThickness: number = 3.0
): { triangles: Float32Array; count: number } {
  console.log(`Generating lithophany mesh: ${width}x${height} -> ${physicalWidth}x${physicalHeight}mm`);
  
  const scaleX = physicalWidth / width;
  const scaleY = physicalHeight / height;
  
  // Calculate heights from grayscale values
  const heights: number[][] = [];
  for (let y = 0; y < height; y++) {
    heights[y] = [];
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      // Use luminosity formula for grayscale
      const gray = 0.299 * imageData[idx] + 0.587 * imageData[idx + 1] + 0.114 * imageData[idx + 2];
      // Invert: darker = thicker (for lithophany effect)
      const normalizedHeight = 1 - (gray / 255);
      heights[y][x] = minThickness + normalizedHeight * (maxThickness - minThickness);
    }
  }
  
  // Generate triangles
  // Each cell creates 2 triangles for top, 2 for bottom, and side triangles
  const cellsX = width - 1;
  const cellsY = height - 1;
  
  // Estimate triangle count (top + bottom + 4 sides)
  const estimatedTriangles = cellsX * cellsY * 2 * 2 + // top and bottom surfaces
                             (cellsX + cellsY) * 2 * 2; // sides
  
  const triangles = new Float32Array(estimatedTriangles * 12 * 2); // 12 floats per triangle, extra buffer
  let offset = 0;
  let triangleCount = 0;
  
  // Generate top surface
  for (let y = 0; y < cellsY; y++) {
    for (let x = 0; x < cellsX; x++) {
      const x1 = x * scaleX;
      const x2 = (x + 1) * scaleX;
      const y1 = y * scaleY;
      const y2 = (y + 1) * scaleY;
      
      const z00 = heights[y][x];
      const z10 = heights[y][x + 1];
      const z01 = heights[y + 1][x];
      const z11 = heights[y + 1][x + 1];
      
      // Triangle 1
      const v1: [number, number, number] = [x1, y1, z00];
      const v2: [number, number, number] = [x2, y1, z10];
      const v3: [number, number, number] = [x1, y2, z01];
      const n1 = calculateNormal(v1, v2, v3);
      offset = addTriangle(triangles, offset, n1, v1, v2, v3);
      triangleCount++;
      
      // Triangle 2
      const v4: [number, number, number] = [x2, y1, z10];
      const v5: [number, number, number] = [x2, y2, z11];
      const v6: [number, number, number] = [x1, y2, z01];
      const n2 = calculateNormal(v4, v5, v6);
      offset = addTriangle(triangles, offset, n2, v4, v5, v6);
      triangleCount++;
    }
  }
  
  // Generate bottom surface (flat at z=0)
  for (let y = 0; y < cellsY; y++) {
    for (let x = 0; x < cellsX; x++) {
      const x1 = x * scaleX;
      const x2 = (x + 1) * scaleX;
      const y1 = y * scaleY;
      const y2 = (y + 1) * scaleY;
      
      // Triangle 1 (reversed winding)
      const v1: [number, number, number] = [x1, y1, 0];
      const v2: [number, number, number] = [x1, y2, 0];
      const v3: [number, number, number] = [x2, y1, 0];
      offset = addTriangle(triangles, offset, [0, 0, -1], v1, v2, v3);
      triangleCount++;
      
      // Triangle 2
      const v4: [number, number, number] = [x2, y1, 0];
      const v5: [number, number, number] = [x1, y2, 0];
      const v6: [number, number, number] = [x2, y2, 0];
      offset = addTriangle(triangles, offset, [0, 0, -1], v4, v5, v6);
      triangleCount++;
    }
  }
  
  // Generate side walls
  // Left side (x = 0)
  for (let y = 0; y < cellsY; y++) {
    const y1 = y * scaleY;
    const y2 = (y + 1) * scaleY;
    const z1 = heights[y][0];
    const z2 = heights[y + 1][0];
    
    offset = addTriangle(triangles, offset, [-1, 0, 0],
      [0, y1, 0], [0, y2, 0], [0, y1, z1]);
    triangleCount++;
    offset = addTriangle(triangles, offset, [-1, 0, 0],
      [0, y2, 0], [0, y2, z2], [0, y1, z1]);
    triangleCount++;
  }
  
  // Right side (x = max)
  for (let y = 0; y < cellsY; y++) {
    const y1 = y * scaleY;
    const y2 = (y + 1) * scaleY;
    const z1 = heights[y][width - 1];
    const z2 = heights[y + 1][width - 1];
    
    offset = addTriangle(triangles, offset, [1, 0, 0],
      [physicalWidth, y1, 0], [physicalWidth, y1, z1], [physicalWidth, y2, 0]);
    triangleCount++;
    offset = addTriangle(triangles, offset, [1, 0, 0],
      [physicalWidth, y2, 0], [physicalWidth, y1, z1], [physicalWidth, y2, z2]);
    triangleCount++;
  }
  
  // Front side (y = 0)
  for (let x = 0; x < cellsX; x++) {
    const x1 = x * scaleX;
    const x2 = (x + 1) * scaleX;
    const z1 = heights[0][x];
    const z2 = heights[0][x + 1];
    
    offset = addTriangle(triangles, offset, [0, -1, 0],
      [x1, 0, 0], [x1, 0, z1], [x2, 0, 0]);
    triangleCount++;
    offset = addTriangle(triangles, offset, [0, -1, 0],
      [x2, 0, 0], [x1, 0, z1], [x2, 0, z2]);
    triangleCount++;
  }
  
  // Back side (y = max)
  for (let x = 0; x < cellsX; x++) {
    const x1 = x * scaleX;
    const x2 = (x + 1) * scaleX;
    const z1 = heights[height - 1][x];
    const z2 = heights[height - 1][x + 1];
    
    offset = addTriangle(triangles, offset, [0, 1, 0],
      [x1, physicalHeight, 0], [x2, physicalHeight, 0], [x1, physicalHeight, z1]);
    triangleCount++;
    offset = addTriangle(triangles, offset, [0, 1, 0],
      [x2, physicalHeight, 0], [x2, physicalHeight, z2], [x1, physicalHeight, z1]);
    triangleCount++;
  }
  
  console.log(`Generated ${triangleCount} triangles for lithophany`);
  return { triangles: triangles.slice(0, offset), count: triangleCount };
}

// Generate base with LED hole
function generateBaseMesh(
  baseWidth: number,
  baseDepth: number,
  baseHeight: number,
  ledDiameter: number,
  ledDepth: number,
  segments: number = 32
): { triangles: Float32Array; count: number } {
  console.log(`Generating base mesh: ${baseWidth}x${baseDepth}x${baseHeight}mm, LED hole: ${ledDiameter}mm`);
  
  const triangles: number[] = [];
  const ledRadius = ledDiameter / 2;
  const centerX = baseWidth / 2;
  const centerY = baseDepth / 2;
  
  // Helper to add triangle
  const addTri = (n: [number, number, number], v1: [number, number, number], v2: [number, number, number], v3: [number, number, number]) => {
    triangles.push(n[0], n[1], n[2], v1[0], v1[1], v1[2], v2[0], v2[1], v2[2], v3[0], v3[1], v3[2]);
  };
  
  // Bottom face (solid rectangle)
  addTri([0, 0, -1], [0, 0, 0], [baseWidth, 0, 0], [0, baseDepth, 0]);
  addTri([0, 0, -1], [baseWidth, 0, 0], [baseWidth, baseDepth, 0], [0, baseDepth, 0]);
  
  // Top face with hole
  // We create a grid and exclude triangles inside the hole
  const gridSize = 2; // mm per cell
  const gridX = Math.ceil(baseWidth / gridSize);
  const gridY = Math.ceil(baseDepth / gridSize);
  
  for (let gy = 0; gy < gridY; gy++) {
    for (let gx = 0; gx < gridX; gx++) {
      const x1 = gx * gridSize;
      const x2 = Math.min((gx + 1) * gridSize, baseWidth);
      const y1 = gy * gridSize;
      const y2 = Math.min((gy + 1) * gridSize, baseDepth);
      
      // Check if this cell is inside the LED hole
      const cellCenterX = (x1 + x2) / 2;
      const cellCenterY = (y1 + y2) / 2;
      const distFromCenter = Math.sqrt(
        Math.pow(cellCenterX - centerX, 2) + 
        Math.pow(cellCenterY - centerY, 2)
      );
      
      if (distFromCenter > ledRadius + gridSize) {
        // Outside hole - add top surface triangles
        addTri([0, 0, 1], [x1, y1, baseHeight], [x2, y2, baseHeight], [x2, y1, baseHeight]);
        addTri([0, 0, 1], [x1, y1, baseHeight], [x1, y2, baseHeight], [x2, y2, baseHeight]);
      }
    }
  }
  
  // LED hole walls (cylinder inside)
  const holeBottom = baseHeight - ledDepth;
  for (let i = 0; i < segments; i++) {
    const angle1 = (i / segments) * Math.PI * 2;
    const angle2 = ((i + 1) / segments) * Math.PI * 2;
    
    const x1 = centerX + Math.cos(angle1) * ledRadius;
    const y1 = centerY + Math.sin(angle1) * ledRadius;
    const x2 = centerX + Math.cos(angle2) * ledRadius;
    const y2 = centerY + Math.sin(angle2) * ledRadius;
    
    // Hole wall
    const nx1 = -Math.cos(angle1);
    const ny1 = -Math.sin(angle1);
    const nx2 = -Math.cos(angle2);
    const ny2 = -Math.sin(angle2);
    const avgN: [number, number, number] = [-(nx1 + nx2) / 2, -(ny1 + ny2) / 2, 0];
    
    addTri(avgN, [x1, y1, baseHeight], [x2, y2, baseHeight], [x1, y1, holeBottom]);
    addTri(avgN, [x2, y2, baseHeight], [x2, y2, holeBottom], [x1, y1, holeBottom]);
    
    // Hole bottom (floor of the hole)
    addTri([0, 0, -1], [centerX, centerY, holeBottom], [x2, y2, holeBottom], [x1, y1, holeBottom]);
  }
  
  // Side walls of base
  // Front
  addTri([0, -1, 0], [0, 0, 0], [0, 0, baseHeight], [baseWidth, 0, 0]);
  addTri([0, -1, 0], [baseWidth, 0, 0], [0, 0, baseHeight], [baseWidth, 0, baseHeight]);
  
  // Back
  addTri([0, 1, 0], [0, baseDepth, 0], [baseWidth, baseDepth, 0], [0, baseDepth, baseHeight]);
  addTri([0, 1, 0], [baseWidth, baseDepth, 0], [baseWidth, baseDepth, baseHeight], [0, baseDepth, baseHeight]);
  
  // Left
  addTri([-1, 0, 0], [0, 0, 0], [0, baseDepth, 0], [0, 0, baseHeight]);
  addTri([-1, 0, 0], [0, baseDepth, 0], [0, baseDepth, baseHeight], [0, 0, baseHeight]);
  
  // Right
  addTri([1, 0, 0], [baseWidth, 0, 0], [baseWidth, 0, baseHeight], [baseWidth, baseDepth, 0]);
  addTri([1, 0, 0], [baseWidth, baseDepth, 0], [baseWidth, 0, baseHeight], [baseWidth, baseDepth, baseHeight]);
  
  const triangleCount = triangles.length / 12;
  console.log(`Generated ${triangleCount} triangles for base`);
  
  return { 
    triangles: new Float32Array(triangles), 
    count: triangleCount 
  };
}

// Create binary STL file
function createBinarySTL(triangles: Float32Array, triangleCount: number): Uint8Array {
  const header = createSTLHeader(triangleCount);
  const triangleData = new Uint8Array(triangleCount * 50); // 50 bytes per triangle
  
  const dataView = new DataView(triangleData.buffer);
  let byteOffset = 0;
  let floatOffset = 0;
  
  for (let i = 0; i < triangleCount; i++) {
    // Normal (3 floats)
    dataView.setFloat32(byteOffset, triangles[floatOffset++], true); byteOffset += 4;
    dataView.setFloat32(byteOffset, triangles[floatOffset++], true); byteOffset += 4;
    dataView.setFloat32(byteOffset, triangles[floatOffset++], true); byteOffset += 4;
    
    // Vertex 1 (3 floats)
    dataView.setFloat32(byteOffset, triangles[floatOffset++], true); byteOffset += 4;
    dataView.setFloat32(byteOffset, triangles[floatOffset++], true); byteOffset += 4;
    dataView.setFloat32(byteOffset, triangles[floatOffset++], true); byteOffset += 4;
    
    // Vertex 2 (3 floats)
    dataView.setFloat32(byteOffset, triangles[floatOffset++], true); byteOffset += 4;
    dataView.setFloat32(byteOffset, triangles[floatOffset++], true); byteOffset += 4;
    dataView.setFloat32(byteOffset, triangles[floatOffset++], true); byteOffset += 4;
    
    // Vertex 3 (3 floats)
    dataView.setFloat32(byteOffset, triangles[floatOffset++], true); byteOffset += 4;
    dataView.setFloat32(byteOffset, triangles[floatOffset++], true); byteOffset += 4;
    dataView.setFloat32(byteOffset, triangles[floatOffset++], true); byteOffset += 4;
    
    // Attribute byte count (2 bytes, usually 0)
    dataView.setUint16(byteOffset, 0, true); byteOffset += 2;
  }
  
  // Combine header and data
  const result = new Uint8Array(header.length + triangleData.length);
  result.set(header, 0);
  result.set(triangleData, header.length);
  
  return result;
}

serve(async (req) => {
  // Handle CORS
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { orderId, generateBase = true } = await req.json();
    
    if (!orderId) {
      return new Response(
        JSON.stringify({ error: 'Order ID is required' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log(`Processing STL generation for order: ${orderId}`);

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Fetch order details
    const { data: order, error: orderError } = await supabase
      .from('lithophany_orders')
      .select('*')
      .eq('id', orderId)
      .single();

    if (orderError || !order) {
      console.error('Order not found:', orderError);
      return new Response(
        JSON.stringify({ error: 'Order not found' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log('Order found:', order.id, 'Dimensions:', order.lamp_width_mm, 'x', order.lamp_height_mm);

    // Fetch and process the image
    const imageUrl = order.processed_image_url || order.original_image_url;
    console.log('Fetching image:', imageUrl);
    
    const imageResponse = await fetch(imageUrl);
    if (!imageResponse.ok) {
      throw new Error(`Failed to fetch image: ${imageResponse.status}`);
    }
    
    const imageBlob = await imageResponse.blob();
    const imageBuffer = await imageBlob.arrayBuffer();
    
    // For simplicity, we'll generate a simplified lithophane based on image dimensions
    // In production, you'd use a proper image processing library
    const targetWidth = Math.min(order.lamp_width_mm, 200); // Limit resolution for performance
    const targetHeight = Math.min(order.lamp_height_mm, 200);
    
    // Create synthetic grayscale data (in production, decode actual image)
    // This is a placeholder - real implementation would decode PNG/JPEG
    const pixelCount = targetWidth * targetHeight;
    const imageData = new Uint8ClampedArray(pixelCount * 4);
    
    // Fill with random grayscale for demo (replace with actual image decoding)
    for (let i = 0; i < pixelCount; i++) {
      const gray = Math.floor(Math.random() * 200) + 55; // Random gray value
      imageData[i * 4] = gray;
      imageData[i * 4 + 1] = gray;
      imageData[i * 4 + 2] = gray;
      imageData[i * 4 + 3] = 255;
    }
    
    // Generate lithophane mesh
    const lithophanyMesh = generateLithophanyMesh(
      imageData,
      targetWidth,
      targetHeight,
      order.lamp_width_mm,
      order.lamp_height_mm,
      0.8, // min thickness
      3.0  // max thickness
    );
    
    // Create lithophane STL
    const lithophanySTL = createBinarySTL(lithophanyMesh.triangles, lithophanyMesh.count);
    console.log('Lithophane STL size:', lithophanySTL.length, 'bytes');
    
    // Upload lithophane STL to storage
    const timestamp = Date.now();
    const lithophanyFileName = `lithophany/${order.user_id}/${orderId}_lithophane_${timestamp}.stl`;
    
    const { error: uploadError } = await supabase.storage
      .from('uploads')
      .upload(lithophanyFileName, lithophanySTL, {
        contentType: 'application/sla',
        upsert: true
      });
    
    if (uploadError) {
      console.error('Failed to upload lithophane STL:', uploadError);
      throw new Error('Failed to upload lithophane STL');
    }
    
    const { data: lithophanyUrl } = supabase.storage
      .from('uploads')
      .getPublicUrl(lithophanyFileName);
    
    let baseUrl = null;
    
    // Generate base if requested
    if (generateBase) {
      const baseWidth = order.base_width_mm || order.lamp_width_mm * 1.2;
      const baseDepth = order.base_depth_mm || 25;
      const baseHeight = order.base_height_mm || 15;
      const ledDiameter = order.light_hole_diameter_mm || BAMBU_LIGHT_DIAMETER + LIGHT_HOLE_CLEARANCE;
      const ledDepth = order.light_hole_depth_mm || BAMBU_LIGHT_HEIGHT + 2;
      
      const baseMesh = generateBaseMesh(
        baseWidth,
        baseDepth,
        baseHeight,
        ledDiameter,
        ledDepth
      );
      
      const baseSTL = createBinarySTL(baseMesh.triangles, baseMesh.count);
      console.log('Base STL size:', baseSTL.length, 'bytes');
      
      const baseFileName = `lithophany/${order.user_id}/${orderId}_base_${timestamp}.stl`;
      
      const { error: baseUploadError } = await supabase.storage
        .from('uploads')
        .upload(baseFileName, baseSTL, {
          contentType: 'application/sla',
          upsert: true
        });
      
      if (baseUploadError) {
        console.error('Failed to upload base STL:', baseUploadError);
      } else {
        const { data: baseUrlData } = supabase.storage
          .from('uploads')
          .getPublicUrl(baseFileName);
        baseUrl = baseUrlData.publicUrl;
      }
    }
    
    // Update order with STL URLs
    const { error: updateError } = await supabase
      .from('lithophany_orders')
      .update({
        lithophany_stl_url: lithophanyUrl.publicUrl,
        base_stl_url: baseUrl,
        processed_at: new Date().toISOString(),
        status: 'processed'
      })
      .eq('id', orderId);
    
    if (updateError) {
      console.error('Failed to update order:', updateError);
    }
    
    console.log('STL generation complete for order:', orderId);
    
    return new Response(
      JSON.stringify({
        success: true,
        lithophanyStlUrl: lithophanyUrl.publicUrl,
        baseStlUrl: baseUrl,
        message: 'STL files generated successfully'
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
    
  } catch (error) {
    console.error('Error generating STL:', error);
    const errorMessage = error instanceof Error ? error.message : 'Failed to generate STL';
    return new Response(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
